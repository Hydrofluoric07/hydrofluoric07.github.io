---
title: JVM笔记
date: 2024-09-21 19:00:00 +0800
categories: [interview, JVM]
tags: [jvm, note, interview]     # TAG names should always be lowercase
typora-root-url: ./..
typora-copy-images-to: ./..\assets\img\2024-9-21-JVM
---

## JVM基础篇

### 初识JVM

Java Virtual Machine

1、运行java字节码文件，解释成字节码让计算机执行，.class由字节码指令构成

2、内存管理，自动为对象方法等分配功能，自动垃圾回收

3、即时编译(Just-In-Time，JIT)，对热点代码进行优化,提升执行效率

java需要实时解释主要为了跨平台特性

### 字节码文件详解

#### JVM组成

![jvm-construction](/assets/img/2024-9-21-JVM/jvm-construction.png)

#### 字节码文件组成

1. 基础信息：魔数、字节码文件对应的Java版本号、访问标识、父类和接口

2. 常量池：字符串常量、类或接口名、字段名
3. 字段：当前类或接口声明的字段信息
4. 方法：方法的字节码指令
5. 属性：类的属性

字节码指令中通过编号引用到常量池的过程称为符号引用

![jvm-class-method](/assets/img/2024-9-21-JVM/jvm-class-method.png)

`int i=0;i=i++;`i的值是什么

![jvm-demo1](/assets/img/2024-9-21-JVM/jvm-demo1.png)

通过分析字节码指令，i++先把0取出来放进操作数栈中，再+1，再将操作数栈中0放入i

分析字节码可知i++和k+=1操作性能一样

```
int i=0,j=0,k=0;
i++;
j=j+1;
k+=1;
```

工具：

命令行：javap -v，JDK自带反编译工具、arthas(dump、jad)、jclasslib

#### 类的生命周期

1. 加载：以二进制字节流获取字节码信息，类加载器加载完类后JVM将字节码中的信息保存到方法区中，生成一个InstanceKlass对象，保存类的所有信息，堆中生成一个java.lang.Class对象，静态字段数据存放在堆区Class对象中，控制开发者访问数据的范围
2. 连接：验证（验证内容是否满足虚拟机规范），准备（给静态变量赋初始值（默认值），final修饰的基本数据类型基本变量会赋代码中的值），解析（将常量池中的符号引用替换成指向内存的直接引用）
3. 初始化：执行静态代码块代码，并为静态变量赋值，执行clinit部分字节码![image-20240922130439482](/assets/img/2024-9-21-JVM/image-20240922130439482.png)连接阶段已经创建并赋初始值
    以下几种方式会导致类的初始化：访问一个类的静态变量或方法（除fina修饰且等号右边是常量)、调用Class.forName(String className)、new创建对象、执行main方法的类
    不会初始化情况：无静态代码块且无静态变量、有静态变量生命但无赋值语句、静态变量用final修饰
     直接访问父类的静态变量不会触发子类的初始化，子类初始化之前会先调用父类初始化
4. 使用
5. 卸载

![image-20240922131804339](/assets/img/2024-9-21-JVM/image-20240922131804339.png)

执行main，需要加载-连接-初始化类，初始化执行static代码块，输出D，再输出A，创建对象不需要再进行加载-连接-初始化，执行非静态代码块，输出C，再执行构造方法输出B

![image-20240922132751366](/assets/img/2024-9-21-JVM/image-20240922132751366.png)

![image-20240922132827567](/assets/img/2024-9-21-JVM/image-20240922132827567.png)

#### 类加载器

Java虚拟机提供给应用程序去获取实现类和接口字节码数据

类加载器的分类：java代码中实现，JVM底层源码实现

启动类加载器Bootstrap ClassLoader，加载jre/lib下的类文件，扩展：通过启动类加载器、使用参数-Xbootclasspath/a:包目录/包名 进行扩展（推荐）

扩展类加载器Extension：JDK提供，默认加载jre/lib/ext文件中的类，扩展：放入jre/lib/ext、使用参数-Djava.ext.dirs=jar包目录

应用程序类加载器Application：依赖jar包，项目中的类

#### 双亲委派机制

当一个类加载器接收到加载类的委派时，会自底向上查找是否加载过，再由顶向下逐个尝试加载（是否在相应目录），解决一个类由哪个类加载器加载，保证1、保证核心类库的安全性完整性和 2、避免重复加载

BootStrapClassLoader>ExtClassLoader(parent=null)>AppClassLoader(parent=ExtClassLoader)，上下级关系，不是继承关系，

使用代码主动加载一个类

1、使用Class.forName 2、通过ClassLoader.loadClass

#### 打破双亲委派机制

1. 自定义类加载器：限定名相同，Tomcat每一个应用有一个独立的类加载器对应的类，重写findClass方法
2. 利用上下文类加载器：JDBC使用DriverManager来管理引入不同数据库驱动
3. OSGI模块化，存在同级之间的类加载器的委托加载

SPI(Service Provider Interface)，JDK内置服务提供发现机制

![image-20240922161110148](/assets/img/2024-9-21-JVM/image-20240922161110148.png)![image-20240922163134196](/assets/img/2024-9-21-JVM/image-20240922163134196.png)![](/assets/img/2024-9-21-JVM/image-20240922163213838.png)![image-20240922163312539](/assets/img/2024-9-21-JVM/image-20240922163312539.png)

![image-20240922163454388](/assets/img/2024-9-21-JVM/image-20240922163454388.png)

### Java内存结构

![image-20240922171419153](/assets/img/2024-9-21-JVM/image-20240922171419153.png)

#### 程序计数器

每个线程通过程序计数器记录当前要执行的字节码指令的地址，存储一个长度固定的内存地址，不会发生内存溢出

#### 栈

栈帧保存方法的基本信息，栈帧中的局部变量表是一个数组，每一个位置是一个槽slot，long和double类型占用两个槽，其他类型一个，编译器可以确定最大深度

局部变量表：存放方法执行过程中所有局部变量（实例方法的this对象，方法参数，方法体中局部变量）。局部变量不再生效槽可以再次使用

帧数据：主要包含动态链接（编号到运行时符号引用与常量池内存地址映射关系），方法出口（上一个栈帧下一条指令地址），异常表（异常捕获的生效范围以及异常发生后跳转到的字节码指令地址）

栈帧内存超过可分配的最大内存会内存溢出，修改栈大小使用虚拟机参数-Xss

#### 堆

堆内存是空间最大的一块空间区域，创建出来的对象都存在于堆

栈上的局部变量表可以存放堆上对象的引用，静态变量也可以

used已使用的堆内存，total已经分配，max为最大可分配

虚拟机参数-Xmx -Xms

#### 方法区

存放基础信息，线程共享，包括类的元信息，运行时常量池，字符串常量池

元信息，一般成为InstanceKlass对象，在类的加载阶段完成

字节码文件中通过编号查表的方式找到常量，称为静态常量池，当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，称为运行时常量池。

JDK7前方法区存放在堆区域中，JDK8后存放在操作系统维护的直接内存，可以使用-XX:MaxMetaspaceSize=值可以限制元空间最大大小

字符串常量池

![image-20240922195914508](/assets/img/2024-9-21-JVM/image-20240922195914508.png)

JDK7前字符串常量是运行时常量池的一部分，JDK7时字符串常量池在堆中，运行时常量池在永久代，JDK8后字符串常量池还在堆

![image-20240922195858281](/assets/img/2024-9-21-JVM/image-20240922195858281.png)

![image-20240922200544518](/assets/img/2024-9-21-JVM/image-20240922200544518.png)
运行结果：false false

![image-20240922200749514](/assets/img/2024-9-21-JVM/image-20240922200749514.png)
运行结果：true false

JDK7前静态变量存放在方法区中，JDK7及其之后存放在堆中的Class对象中

#### 直接内存

JDK8及其之后方法区在直接内存中的元空间，主要为了解决回收堆中对象影响对象的创建和使用以及IO操作需要把文件读入直接内存再复制到堆中的问题（现直接放入直接内存，堆上维护引用）

调整参数-XX:MaxDirectMemorySize

![image-20240922202749706](/assets/img/2024-9-21-JVM/image-20240922202749706.png)

![image-20240922202810373](/assets/img/2024-9-21-JVM/image-20240922202810373.png)

![image-20240922202836259](/assets/img/2024-9-21-JVM/image-20240922202836259.png)

### 自动垃圾回收(Garbage Collection,GC)

内存泄漏：不再使用的对象在系统中未被回收，内存泄漏可能导致内存溢出

线程不共享部分随线程销毁而销毁，不会产生内存泄漏

#### 方法区的回收

同时满足3个条件：

1. 实例对象与子类对象都被回收

2. 加载该类的类加载器已被回收
3. 对应的java.lang.Class对象没有被引用

手动触发可以使用`System.gc()`

#### 堆回收

##### 引用计数法和可达性分析法

判断对象是否能被回收根据对象能否通过引用获取

查看垃圾回收日志：-verbose:gc

引用计数法：创建引用计数器（维护计数器影响系统性能，存在循环引用问题）

可达性分析法：将对象分为垃圾回收的根对象(GC Root)和普通对象，某个对象到GC Root对象引用链不可达则可被回收

GC Root对象：

线程Thread引用线程栈帧的方法参数和局部变量等、系统类加载器加载的java.lang.Class对象，监视器对象，本地方法调用时使用的全局对象

查看GC Root：arthas和Eclipse Memory Analyzer

##### 五种对象引用

强引用

软引用：当一个对象只有软引用关联且内存不足时会将对象回收，常用于缓存，JDK提供了SoftReference类，new SoftReference<对象类型>(对象)

![image-20240922215327976](/assets/img/2024-9-21-JVM/image-20240922215327976.png)

![image-20240922214827345](/assets/img/2024-9-21-JVM/image-20240922214827345.png)

弱引用：直接被回收,WeakReference类实现，主要用在ThreadLocal，也可以使用引用队列

虚引用：不能获取包含的对象，用途是当对象被回收时可以收到相应通知，PhantomReference

终结器引用：对象被回收时终结器引用会关联对象并放置在Finalizer类中的引用队列中，再由一条FinalizerThread线程从队列中获取并执行finalize方法， 第二次被回收才被真正回收

##### 垃圾回收算法

找到存活的对象，释放不再存活对象的内存，通过单独GC线程，会有部分阶段停止所有用户线程，STW(Stop The World)

1. 标记-清除算法：标记阶段可达性分析算法标记存活对象，清除阶段删除非存活对象，优点实现简单，缺点碎片化问题（细小的内存单元可能无法再分配），分配速度慢（遍历维护的空闲链表找合适内存空间）

2. 复制算法：堆空间划分为From和To空间，分配对象使用From空间，GC阶段将From的存活对象（GC Root以及关联的对象）复制到To，将两块空间名字互换，优点吞吐量高，不会发生内存碎片化，缺点内存使用效率低

3. 标记-整理算法：解决标记-清除内存碎片化，标记阶段相同，整理阶段将存活对象移到堆一端，再清理，优点内存使用效率高，不会产生碎片化，缺点整理阶段效率不高

4. 分代GC：组合上3种使用![image-20240923101200180](/assets/img/2024-9-21-JVM/image-20240923101200180.png)

    ![image-20240923101814300](/assets/img/2024-9-21-JVM/image-20240923101814300.png)-XX:+UseSerialGC使用分代回收![image-20240923101426055](/assets/img/2024-9-21-JVM/image-20240923101426055.png)
    ![image-20240923101922257](/assets/img/2024-9-21-JVM/image-20240923101922257.png)
    特殊情况部分未达到阈值可能放入老年代，因此先minor gc
    ![image-20240923102154178](/assets/img/2024-9-21-JVM/image-20240923102154178.png)

评价GC算法

吞吐量：CPU执行用户代码与总执行时间比值，t/(t+GC时间)

最大暂停时间：最大STW

堆使用效率：堆内存使用方式

堆内存越大，最大暂停时间越长，降低最大暂停时间会降低吞吐率

##### 垃圾回收器

为什么分代GC要把堆分为年轻代和老年代

大部分对象创建之后很快可以被回收，新生代远小于老年代，老年代可以存放bean对象

![image-20240923103039388](/assets/img/2024-9-21-JVM/image-20240923103039388.png)
![image-20240923103703031](/assets/img/2024-9-21-JVM/image-20240923103703031.png)

![image-20240923103435201](/assets/img/2024-9-21-JVM/image-20240923103435201.png)
![image-20240923103453146](/assets/img/2024-9-21-JVM/image-20240923103453146.png)
![image-20240923103753625](/assets/img/2024-9-21-JVM/image-20240923103753625.png)
![image-20240923103942203](/assets/img/2024-9-21-JVM/image-20240923103942203.png)
![image-20240923104214210](/assets/img/2024-9-21-JVM/image-20240923104214210.png)
![image-20240923104254028](/assets/img/2024-9-21-JVM/image-20240923104254028.png)
![image-20240923142410129](/assets/img/2024-9-21-JVM/image-20240923142410129.png)
![image-20240923142610010](/assets/img/2024-9-21-JVM/image-20240923142610010.png)
![image-20240923142950174](/assets/img/2024-9-21-JVM/image-20240923142950174.png)

##### G1垃圾回收器

![image-20240923143542164](/assets/img/2024-9-21-JVM/image-20240923143542164.png)

将堆划分成多个大小相同的区域，称为区Region，分为Eden、Survivor、Old区，-XX:G1HeapRegionSize=32m

年轻代回收(Young GC)，回收Eden区和Survivor对象，会导致STW，-XX:MaxGcPauseMillis=n设置最大暂停时间，新创建对象放在Eden区，年轻代区不足时Young GC，标记出Eden和Survivor存活对象，根据配置的最大暂停时间选择某些区域将存活对象（根据过去回收平均耗时和最大暂停时间计算）复制到一个新的Survivo区中（年龄+1），清空这些区域，年龄达到阈值放入老年代，大对象超过Region的一半会放入老年代(Humongous区)，多次回收后总堆占有率达到阈值混合回收MixedGC，回收所有年轻代和部分老年代对象以及大对象区，采用复制算法不会产生内存对象

-XX:+UseG1GC

-XX:MaxGCPauseMills=最大暂停时间

![image-20240923145044302](/assets/img/2024-9-21-JVM/image-20240923145044302.png)

![image-20240923144853144](/assets/img/2024-9-21-JVM/image-20240923144853144.png)

![image-20240923145418354](/assets/img/2024-9-21-JVM/image-20240923145418354.png)

## 实战篇 

### 内存调优

内存泄漏：一个不再使用的对象仍然在GC Root引用链上不会被回收，大多数情况是堆内存泄漏 

发现问题：top命令查看基础进程信息

VisualVM、Arthas（可以使用tunnel来管理所有需要监控的程序）、Promethus（采集，告警）+Grafana（可视化展示），

![image-20240923155656488](/assets/img/2024-9-21-JVM/image-20240923155656488.png)
![image-20240923162108474](/assets/img/2024-9-21-JVM/image-20240923162108474.png)

#### 内存泄漏原因

![image-20240923162658407](/assets/img/2024-9-21-JVM/image-20240923162658407.png)

1. 代码中内存泄漏

    在定义新类时没有重写正确的equals()和hashCode()方法。在使用HashMap的场景下，
    如果使用这个类对象作为key,HashMap在判断key是否已经存在时会使用这些方法，如
    果重写方式不正确，会导致相同的数据被保存多份。

2. 内部类引用外部类
    非静态内部类默认引用外部类，代码引用了这个内部类会导致外部类也被引用，匿名内部类对象在非静态方法中被创建会持有调用者对象，垃圾回收时无法回收调用者

3. ThreadLocal的使用
    ![image-20240923171336573](/assets/img/2024-9-21-JVM/image-20240923171336573.png)

4. String的intern方法
    ![image-20240923171616978](/assets/img/2024-9-21-JVM/image-20240923171616978.png)

5. 通过静态字段保存对象
    ![image-20240923171932564](/assets/img/2024-9-21-JVM/image-20240923171932564.png)

6. 资源没有正确关闭

并发请求问题：并发请求量大，同时处理数据时间长，超过内存上限导致内存溢出

![image-20240923182925812](/assets/img/2024-9-21-JVM/image-20240923182925812.png)

诊断原因，保存堆内存生成内存快照，MAT内存泄漏检测，生成内存快照的ava虚拟机参数：
-XX:+HeapDumpOnOutOfMemoryError:发生OutOfMemoryError错误时，自动生成nprof内存快照文件
-XX:HeapDumpPath=:指定hprof文件的输出路径

-XX:+HeapDumpBeforeFullGC可以在FullGC前生成快照

Mybatis导致内存溢出

![image-20240924080148197](/assets/img/2024-9-21-JVM/image-20240924080148197.png)

导出大文件内存溢出

![image-20240924081452503](/assets/img/2024-9-21-JVM/image-20240924081452503.png)

ThreadLocal使用时占用大量内存

在拦截器preHandle方法中去解析请求头中的数据，并放入一些数据到
ThreadLocal中方便后续使用，在拦截器的afterCompletion方法中，必须要将ThreadLocal
中的数据清理掉，不建议在postHandler

MAT内存泄漏检测原理 支配树

![image-20240923185405244](/assets/img/2024-9-21-JVM/image-20240923185405244.png)
![image-20240923185515694](/assets/img/2024-9-21-JVM/image-20240923185515694.png)

#### 修复问题

![image-20240923190457298](/assets/img/2024-9-21-JVM/image-20240923190457298.png)

![image-20240923190654677](/assets/img/2024-9-21-JVM/image-20240923190654677.png)

生成内存快照：通过完整内存快照判断问题，内存大生成快照过程影响使用

在线定位问题，无需生成内存快照，对用户影响小，无法查看内存快照

![image-20240924084456174](/assets/img/2024-9-21-JVM/image-20240924084456174.png)

1、什么是内存溢出，什么是内存泄漏？
内存泄漏(memory leak):在Java中如果不再使用一个对像，但是该对象依然在GC ROOT的引用链上，这个对象就不会被垃圾回收器回收，这种情况就称之为
内存泄漏。
内存溢出指的是内存的使用量超过了Java虚拟机可以分配的上限，最终产生了内存溢出DutOfMemory的错误。

2、内存溢出有哪几种产生的原因？
1、持续的内存泄漏：内存泄漏持续发生，不可被回收同时不再使用的内存越来越多，最终内存被消耗完无法分配更多的内存取使用，导致内存溢出。
2、并发请求问题：用户通过发送请求向Java应用获取数据，正常情况下Java应用将数据返回之后，这部分数据就可以在内存中被释放掉。但是由于用户的并发请求量有可能很大，同时处理数据的时间很长，导致大量的数据存在于内存中，最终超过了内
存的上限，导致内存溢出。

3、解决内存泄漏问题的方法是什么？
1、发现问题，通过监控工具尽可能尽早地发现内存慢慢变大的现象。
2、诊断原因，通过分析内存快照或者在线分析方法调用过程，诊断问题产生的根源，
定位到出现问题的源代码。
3、修复源代码中的问题，如代码bug、技术方案不合理、业务设计不合理等等。
4、在测试环境验证问题是否已经解决，最后发布上线。

### GC调优

通过JVM参数设置、特定垃圾回收器的JVM参数设置、解决频繁的FULLGC引起的程序性能问题

指标：1、吞吐量，分为业务和垃圾回收吞吐量，程序需要完成的业务数量 优化执行性能、优化垃圾回收吞吐量

2、延迟：请求到响应时间，=GC延迟+业务执行时间

3、内存使用量：Java应用占用系统内存最大值

工具：Gceasy

![image-20240924091337427](/assets/img/2024-9-21-JVM/image-20240924091337427.png)

![image-20240924091632050](/assets/img/2024-9-21-JVM/image-20240924091632050.png)
![image-20240924091836855](/assets/img/2024-9-21-JVM/image-20240924091836855.png)

GC日志

使用方法(JDK8及以下)：-XX:+PrintGCDetails

-Xloggc:文件名
使用方法(JDK9+)：-Xlog:gc*:f1Le=文件名

GC Viewer将GC日志转换成图表

常见GC模式：

1. 正常情况：锯齿状，对象创建内存高，垃圾回收下降
2. 缓存对象过多：保存了大量缓存，同正常情况但最小内存高
3. 内存泄漏：垃圾回收后下降内存越来越少
4. 持续的Full GC
5. 元空间不足导致的持续Full GC

#### 优化JVM参数

![image-20240924094047502](/assets/img/2024-9-21-JVM/image-20240924094047502.png)

![image-20240924094717016](/assets/img/2024-9-21-JVM/image-20240924094717016.png)

![image-20240924094913162](/assets/img/2024-9-21-JVM/image-20240924094913162.png)

![image-20240924095259688](/assets/img/2024-9-21-JVM/image-20240924095259688.png)

![image-20240924095404049](/assets/img/2024-9-21-JVM/image-20240924095404049.png)

![image-20240924095637048](/assets/img/2024-9-21-JVM/image-20240924095637048.png)

![image-20240924095521454](/assets/img/2024-9-21-JVM/image-20240924095521454.png)

![image-20240924095821607](/assets/img/2024-9-21-JVM/image-20240924095821607.png)

#### 更换垃圾回收器

![image-20240924100105631](/assets/img/2024-9-21-JVM/image-20240924100105631.png)

#### 优化垃圾回收器参数

CMS的并发模式失败(concurrent mode failure)现象。由于CMS的垃圾清理线程和用户线程是并行进行的，如果在并发清理的过程中老年代的空间不足以容纳放入老年代的对象，会产生并发模式失败。![image-20240924103532258](/assets/img/2024-9-21-JVM/image-20240924103532258.png)

[黑马程序员-内存调优和GC调优实战](https://www.bilibili.com/video/BV1r94y1b7eS?p=68)

### 性能调优

1. top命令查看CPU占用率高![image-20240924162047143](/assets/img/2024-9-21-JVM/image-20240924162047143.png)
2. 请求单个服务时间长，多服务使用skywalking工具![image-20240924164623240](/assets/img/2024-9-21-JVM/image-20240924164623240.png)
3. 启动后正常，运行一段时间后无法处理请求![image-20240924165317323](/assets/img/2024-9-21-JVM/image-20240924165317323.png)
    

查看线程转储文件Thread Dump，jstack、visualvm工具

名称、优先级prio、Java ID(tid)、本地ID(nid)、状态、栈追踪（栈帧信息）

判断一个方法耗时

方法上打印时间再通过发起http请求测试不准确，（1）测试时有些对象懒加载，第一次请求较慢 （2）JIT会优化代码，测试时间不一定等于用户处理时间

使用OpenJDK中的JMH基准测试框架对某些特定的方法比如加密算法进行基准测试，JMH可以完全模拟运行环境中的)va虚拟机参数，同时支持预热能通过JIT执行优化后的代码获得更为准确的数据。

![image-20240924174030497](/assets/img/2024-9-21-JVM/image-20240924174030497.png)

## 高级篇

### GraalVM

高性能JDK，比OpenJDK和OracleJDK性能好

#### 两种模式

JIT(Just-In-Time)，即时编译模式

AOT(Ahead-Of-Time)，提前编译模式

### 即时编译器JIT

### ASM字节码增强

### Java Agent技术

### ZGC

## 原理篇

### Java对象布局

### 异常、反射原理

### G1垃圾回收器工作原理

### 编译器优化

## 面试篇

### 常见的JVM参数

### Tomcat的类加载器

### ThreadLocal会内存泄漏吗

### 如何优化减少Full GC

### 三色标记法是什么 