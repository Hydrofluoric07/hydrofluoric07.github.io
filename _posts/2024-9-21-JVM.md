---
title: JVM笔记
date: 2024-09-21 19:00:00 +0800
categories: [interview, JVM]
tags: [jvm, note, interview]     # TAG names should always be lowercase
typora-root-url: ./..
typora-copy-images-to: ./..\assets\img\2024-9-21-JVM
---

## JVM基础篇

### 初识JVM

Java Virtual Machine

1、运行java字节码文件，解释成字节码让计算机执行，.class由字节码指令构成

2、内存管理，自动为对象方法等分配功能，自动垃圾回收

3、即时编译(Just-In-Time，JIT)，对热点代码进行优化,提升执行效率

java需要实时解释主要为了跨平台特性

### 字节码文件详解

#### JVM组成

![jvm-construction](/assets/img/2024-9-21-JVM/jvm-construction.png)

#### 字节码文件组成

1. 基础信息：魔数、字节码文件对应的Java版本号、访问标识、父类和接口

2. 常量池：字符串常量、类或接口名、字段名
3. 字段：当前类或接口声明的字段信息
4. 方法：方法的字节码指令
5. 属性：类的属性

字节码指令中通过编号引用到常量池的过程称为符号引用

![jvm-class-method](/assets/img/2024-9-21-JVM/jvm-class-method.png)

`int i=0;i=i++;`i的值是什么

![jvm-demo1](/assets/img/2024-9-21-JVM/jvm-demo1.png)

通过分析字节码指令，i++先把0取出来放进操作数栈中，再+1，再将操作数栈中0放入i

分析字节码可知i++和k+=1操作性能一样

```
int i=0,j=0,k=0;
i++;
j=j+1;
k+=1;
```

工具：

命令行：javap -v，JDK自带反编译工具、arthas(dump、jad)、jclasslib

#### 类的生命周期

1. 加载：以二进制字节流获取字节码信息，类加载器加载完类后JVM将字节码中的信息保存到方法区中，生成一个InstanceKlass对象，保存类的所有信息，堆中生成一个java.lang.Class对象，静态字段数据存放在堆区Class对象中，控制开发者访问数据的范围
2. 连接：验证（验证内容是否满足虚拟机规范），准备（给静态变量赋初始值（默认值），final修饰的基本数据类型基本变量会赋代码中的值），解析（将常量池中的符号引用替换成指向内存的直接引用）
3. 初始化：执行静态代码块代码，并为静态变量赋值，执行clinit部分字节码![image-20240922130439482](/assets/img/2024-9-21-JVM/image-20240922130439482.png)连接阶段已经创建并赋初始值
    以下几种方式会导致类的初始化：访问一个类的静态变量或方法（除fina修饰且等号右边是常量)、调用Class.forName(String className)、new创建对象、执行main方法的类
    不会初始化情况：无静态代码块且无静态变量、有静态变量生命但无赋值语句、静态变量用final修饰
     直接访问父类的静态变量不会触发子类的初始化，子类初始化之前会先调用父类初始化
4. 使用
5. 卸载

![image-20240922131804339](/assets/img/2024-9-21-JVM/image-20240922131804339.png)

执行main，需要加载-连接-初始化类，初始化执行static代码块，输出D，再输出A，创建对象不需要再进行加载-连接-初始化，执行非静态代码块，输出C，再执行构造方法输出B

![image-20240922132751366](/assets/img/2024-9-21-JVM/image-20240922132751366.png)

![image-20240922132827567](/assets/img/2024-9-21-JVM/image-20240922132827567.png)

#### 类加载器

Java虚拟机提供给应用程序去获取实现类和接口字节码数据

类加载器的分类：java代码中实现，JVM底层源码实现

启动类加载器Bootstrap ClassLoader，加载jre/lib下的类文件，扩展：通过启动类加载器、使用参数-Xbootclasspath/a:包目录/包名 进行扩展（推荐）

扩展类加载器Extension：JDK提供，默认加载jre/lib/ext文件中的类，扩展：放入jre/lib/ext、使用参数-Djava.ext.dirs=jar包目录

应用程序类加载器Application：依赖jar包，项目中的类

#### 双亲委派机制

当一个类加载器接收到加载类的委派时，会自底向上查找是否加载过，再由顶向下逐个尝试加载（是否在相应目录），解决一个类由哪个类加载器加载，保证1、保证核心类库的安全性完整性和 2、避免重复加载

BootStrapClassLoader>ExtClassLoader(parent=null)>AppClassLoader(parent=ExtClassLoader)，上下级关系，不是继承关系，

使用代码主动加载一个类

1、使用Class.forName 2、通过ClassLoader.loadClass

#### 打破双亲委派机制

1. 自定义类加载器：限定名相同，Tomcat每一个应用有一个独立的类加载器对应的类，重写findClass方法
2. 利用上下文类加载器：JDBC使用DriverManager来管理引入不同数据库驱动
3. OSGI模块化，存在同级之间的类加载器的委托加载

SPI(Service Provider Interface)，JDK内置服务提供发现机制

![image-20240922161110148](/assets/img/2024-9-21-JVM/image-20240922161110148.png)![image-20240922163134196](/assets/img/2024-9-21-JVM/image-20240922163134196.png)![](/assets/img/2024-9-21-JVM/image-20240922163213838.png)![image-20240922163312539](/assets/img/2024-9-21-JVM/image-20240922163312539.png)

![image-20240922163454388](/assets/img/2024-9-21-JVM/image-20240922163454388.png)

### Java内存结构

![image-20240922171419153](/assets/img/2024-9-21-JVM/image-20240922171419153.png)

#### 程序计数器

每个线程通过程序计数器记录当前要执行的字节码指令的地址，存储一个长度固定的内存地址，不会发生内存溢出

#### 栈

栈帧保存方法的基本信息，栈帧中的局部变量表是一个数组，每一个位置是一个槽slot，long和double类型占用两个槽，其他类型一个，编译器可以确定最大深度

局部变量表：存放方法执行过程中所有局部变量（实例方法的this对象，方法参数，方法体中局部变量）。局部变量不再生效槽可以再次使用

帧数据：主要包含动态链接（编号到运行时符号引用与常量池内存地址映射关系），方法出口（上一个栈帧下一条指令地址），异常表（异常捕获的生效范围以及异常发生后跳转到的字节码指令地址）

栈帧内存超过可分配的最大内存会内存溢出，修改栈大小使用虚拟机参数-Xss

#### 堆

堆内存是空间最大的一块空间区域，创建出来的对象都存在于堆

栈上的局部变量表可以存放堆上对象的引用，静态变量也可以

used已使用的堆内存，total已经分配，max为最大可分配

虚拟机参数-Xmx -Xms

#### 方法区

存放基础信息，线程共享，包括类的元信息，运行时常量池，字符串常量池

元信息，一般成为InstanceKlass对象，在类的加载阶段完成

字节码文件中通过编号查表的方式找到常量，称为静态常量池，当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，称为运行时常量池。

JDK7前方法区存放在堆区域中，JDK8后存放在操作系统维护的直接内存，可以使用-XX:MaxMetaspaceSize=值可以限制元空间最大大小

字符串常量池

![image-20240922195914508](/assets/img/2024-9-21-JVM/image-20240922195914508.png)

JDK7前字符串常量是运行时常量池的一部分，JDK7时字符串常量池在堆中，运行时常量池在永久代，JDK8后字符串常量池还在堆

![image-20240922195858281](/assets/img/2024-9-21-JVM/image-20240922195858281.png)

![image-20240922200544518](/assets/img/2024-9-21-JVM/image-20240922200544518.png)
运行结果：false false

![image-20240922200749514](/assets/img/2024-9-21-JVM/image-20240922200749514.png)
运行结果：true false

JDK7前静态变量存放在方法区中，JDK7及其之后存放在堆中的Class对象中

#### 直接内存

JDK8及其之后方法区在直接内存中的元空间，主要为了解决回收堆中对象影响对象的创建和使用以及IO操作需要把文件读入直接内存再复制到堆中的问题（现直接放入直接内存，堆上维护引用）

调整参数-XX:MaxDirectMemorySize

![image-20240922202749706](/assets/img/2024-9-21-JVM/image-20240922202749706.png)

![image-20240922202810373](/assets/img/2024-9-21-JVM/image-20240922202810373.png)

![image-20240922202836259](/assets/img/2024-9-21-JVM/image-20240922202836259.png)

### 自动垃圾回收(Garbage Collection,GC)

内存泄漏：不再使用的对象在系统中未被回收，内存泄漏可能导致内存溢出

线程不共享部分随线程销毁而销毁，不会产生内存泄漏

#### 方法区的回收

同时满足3个条件：

1. 实例对象与子类对象都被回收

2. 加载该类的类加载器已被回收
3. 对应的java.lang.Class对象没有被引用

手动触发可以使用`System.gc()`

#### 堆回收

##### 引用计数法和可达性分析法

判断对象是否能被回收根据对象能否通过引用获取

查看垃圾回收日志：-verbose:gc

引用计数法：创建引用计数器（维护计数器影响系统性能，存在循环引用问题）

可达性分析法：将对象分为垃圾回收的根对象(GC Root)和普通对象，某个对象到GC Root对象引用链不可达则可被回收

GC Root对象：

线程Thread引用线程栈帧的方法参数和局部变量等、系统类加载器加载的java.lang.Class对象，监视器对象，本地方法调用时使用的全局对象

查看GC Root：arthas和Eclipse Memory Analyzer

##### 五种对象引用

强引用

软引用：当一个对象只有软引用关联且内存不足时会将对象回收，常用于缓存，JDK提供了SoftReference类，new SoftReference<对象类型>(对象)

![image-20240922215327976](/assets/img/2024-9-21-JVM/image-20240922215327976.png)

![image-20240922214827345](/assets/img/2024-9-21-JVM/image-20240922214827345.png)

弱引用：直接被回收,WeakReference类实现，主要用在ThreadLocal，也可以使用引用队列

虚引用：不能获取包含的对象，用途是当对象被回收时可以收到相应通知，PhantomReference

终结器引用：对象被回收时终结器引用会关联对象并放置在Finalizer类中的引用队列中，再由一条FinalizerThread线程从队列中获取并执行finalize方法， 第二次被回收才被真正回收

### 类的生命周期和类加载器

## 实战篇

### 内存泄漏

### GC调优

### 性能调优

## 高级篇

### 即时编译器JIT

### ASM字节码增强

### Java Agent技术

### ZGC

### GraalVM

## 原理篇

### Java对象布局

### 异常、反射原理

### G1垃圾回收器工作原理

### 编译器优化

## 面试篇

### 常见的JVM参数

### Tomcat的类加载器

### ThreadLocal会内存泄漏吗

### 如何优化减少Full GC

### 三色标记法是什么