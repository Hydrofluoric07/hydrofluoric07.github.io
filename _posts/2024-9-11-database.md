---
title: 数据库面试知识点
date: 2024-09-11 15:51:19 +0800
categories: [interview, database]
tags: [database, note, interview]     # TAG names should always be lowercase
typora-root-url: ./..
---

## 数据库基础

### 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?

![database](/assets/img/2024-9-11-database/database.png)

DB database

DBMS database management system

DBS database System

DBA database administrator

### 什么是元组, 码, 候选码, 主码, 外码, 主属性, ⾮主属性？

 元组 ：关系是⼀张表，表中的每⾏（即数据库中的 每条记录）就是⼀个元组，每列就是⼀个属性。 在⼆维表⾥，元组也称为⾏。 

码 ：码就是能唯⼀标识实体的属性，对应表中的列。

 候选码 ： 若关系中的某⼀属性或属性组的值能唯⼀的标识⼀个元组，⽽其任何、⼦集都不能再 标识，则称该属性组为候选码。例如：在学⽣实体中，“学号”是能唯⼀的区分学⽣实体的，同时 ⼜假设“姓名”、“班级”的属性组合⾜以区分学⽣实体，那么{学号}和{姓名，班级}都是候选码。 

主码 : 主码也叫主键。主码是从候选码中选出来的。 ⼀个实体集中只能有⼀个主码，但可以有 多个候选码。 

外码 : 外码也叫外键。如果⼀个关系中的⼀个属性是另外⼀个关系中的主码则这个属性为外码。 

主属性 ： 候选码中出现过的属性称为主属性。如果主码是⼀个属性组，那么属性组中的属性都是主属性。 

⾮主属性： 不包含在任何⼀个候选码中的属性称为⾮主属性

### 主键和外键有什么区别?

主键(主码) ：主键⽤于唯⼀标识⼀个元组，不能有重复，不允许为空。⼀个表只能有⼀个主键。 

外键(外码) ：外键⽤来和其他表建⽴联系⽤，外键是另⼀表的主键，外键是可以有重复的，可以 是空值。⼀个表可以有多个外键。

### 什么是 ER 图？

E-R 图 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的⽅法， ⽤来描述现实世界的概念模型。

### 数据库范式(待续)

1NF：属性不可再分。 

2NF：1NF 的基础之上，消除了⾮主属性对于码的部分函数依赖。 

3NF：3NF 在 2NF 的基础之上，消除了⾮主属性对于码的传递函数依赖 。

### 什么是存储过程?

存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行

存储过程难以调试和扩展，没有移植性

### drop、delete 与 truncate 区别？

drop table 表名，删除表

truncate table 表名 ，清空表数据，再插⼊数据的时⾃增⻓ id  从 1 开始

delete from 表名 where 列名=值 ，删除某⼀⾏的数据，如果不加 where ⼦ 句和 truncate table 表名 作⽤类似

delete、truncate删除表的数据，drop删除表的结构

### DML和DDL

DML(Data Manipulation Language)对表记录的insert、update、delete、select

DDL(Data Definition Language)定义关系模式、删除关系、修改关系模式以及创建数据库中的各种对象，比如表、聚簇、索引、视图、函数、存储过程和触发器等等

drop>truncate>delete

delete执行时产生日志，truncate将表的自增值重置和索引恢复初始大小

drop会把表占用空间释放

### 数据库设计通常分为哪⼏步?

1. 需求分析 : 分析⽤户的需求，包括数据、功能和性能需求。
2.  概念结构设计 : 主要采⽤ E-R 模型进⾏设计，包括画 E-R 图。 
3.  逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
4. 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。
5. 数据库实施 : 包括编程、测试和试运⾏
6. 数据库的运⾏和维护 : 系统的运⾏与数据库的⽇常维护。

## MySQL

### 关系型数据库

是⼀种建⽴在关系模型的基础上的数据库，关系模型表明了数据库中所存 储的数据之间的联系（⼀对⼀、⼀对多、多对多）

### MySQL存储引擎

5.5.5之前默认MyISAM，之后InnoDB

可以为不同的数据库表设置不 同的存储引擎以适应不同场景的需要，存储引擎是基于表的，⽽不是数据库。

|                                          | MyISAM                   | InnoDB             |
| ---------------------------------------- | ------------------------ | ------------------ |
| 是否支持行级锁                           | 表级锁，并导致发写性能低 | 行级锁             |
| 是否支持事务                             | 否                       | 是                 |
| 是否支持外键                             | 否                       | 是                 |
| 是否⽀持数据库异常崩溃后的安全恢复       | 否                       | 是                 |
| 是否支持MVCC(一种提高数据库并发性能技术) | 否                       | 是                 |
| 索引实现，都基于B+Tree                   | 数据文件本身是索引文件   | 索引文件与数据分离 |

### MySQL事务

事务用于保证数据的一致性

事务未说明指分布式事务往往指数据库事务，数据库事务可以保证多个对数据库的操作构成一个逻辑上的整体，遵循要么都执⾏，要么都不执⾏，是事务是逻辑上的⼀组操作。

#### 事务的ACID特性

- 原子性(Atomicity)，事务是最⼩的执⾏单位，不允许分割

- 一致性(Consistency)，执行事务前后数据保持一致
- 隔离性(isolation)，并发访问数据库时一个事务不被其他事务干扰
- 持久性(Durability)，一个事务被提交之后对数据库中数据改变时持久的

AID是手段，C是目的

### 并发事务带来了哪些问题?

- 脏读（Dirty read）: 当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提交 到数据库中，这时另外⼀个事务也访问了这个数据，然后使⽤了这个数据。因为这个数据是还没 有提交的数据，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是 不正确的。 
-  丢失修改（Lost to modify）: 指在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数据， 那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事务内的修 改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。 
- 不可重复读（Unrepeatable read）: 指在⼀个事务内多次读同⼀数据。在这个事务还没有结束 时，另⼀个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修 改导致第⼀个事务两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不 ⼀样的情况，因此称为不可重复读。 
- 幻读（Phantom read）: 幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据， 接着另⼀个并发事务（T2）插⼊了⼀些数据时。在随后的查询中，第⼀个事务（T1）就会发现 多了⼀些原本不存在的记录，就好像发⽣了幻觉⼀样，所以称为幻读。

#### 不可重复读和幻读有什么区别呢？

不可重复读的重点是内容修改或者记录减少⽐如多次读取⼀条记录发现其中某些记录的值被修 改； 幻读的重点在于记录新增⽐如多次执⾏同⼀条查询语句（DQL）时，发现查到的记录增加了。 幻读其实可以看作是不可重复读的⼀种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复 读的⽅案不⼀样。

#### SQL 标准定义了哪些事务隔离级别?（待续）

- READ-UNCOMMITTED(读取未提交) ： 最低的隔离级别，允许读取尚未提交的数据变更，可能 会导致脏读、幻读或不可重复读。 
- READ-COMMITTED(读取已提交) ： 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是 幻读或不可重复读仍有可能发⽣。 
- REPEATABLE-READ(可重复读) ： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本 身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 
- SERIALIZABLE(可串⾏化) ： 最⾼的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次 逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读 以及幻读。

#### MySQL 的隔离级别是基于锁实现的吗？

SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都 是基于 MVCC 实现。

#### MySQL 的默认隔离级别是什么?

MySQL InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重读）

### MySQL锁

#### 表级锁和⾏级锁了解吗？有什么区别？

MyISAM 仅仅⽀持表级锁(table-level locking)，是MySQL 中锁定粒度最⼤的⼀种锁，这在并发写的情况下性⾮常差。 InnoDB 不光⽀持表级锁(table-level locking)，还⽀持⾏级锁(row-level locking)，默认为⾏级锁。⾏ 级锁的粒度最⼩，仅对相关的记录上锁即可（对⼀⾏或者多⾏记录加锁），并发度⾼，但加锁的开销 也最⼤，加锁慢，会出现死锁。

#### ⾏级锁的使⽤有什么注意事项？

InnoDB 的⾏锁是针对索引字段加的锁，表级锁是针对⾮索引字段加的锁。当我们执⾏ UPDATE 、 DELETE 语句时，如果 WHERE 条件中字段没有命中唯⼀索引（如主键索引）或者索引失效的话，就 会导致扫描全表对表中的所有⾏记录进⾏加锁

#### 共享锁和排他锁(待续，没看懂)

## Redis

### 简介

一个使用c语言开发的数据库，是内存数据库，读写速度非常快，被广泛用于缓存方向
