---
title: 数据库面试知识点
date: 2024-09-11 15:51:19 +0800
categories: [interview, database]
tags: [database, note, interview]     # TAG names should always be lowercase
typora-root-url: ./..
---

## 数据库基础

### 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?

![database](/assets/img/2024-9-11-database/database.png)

DB database

DBMS database management system

DBS database System

DBA database administrator

### 什么是元组, 码, 候选码, 主码, 外码, 主属性, ⾮主属性？

 元组 ：关系是⼀张表，表中的每⾏（即数据库中的 每条记录）就是⼀个元组，每列就是⼀个属性。 在⼆维表⾥，元组也称为⾏。 

码 ：码就是能唯⼀标识实体的属性，对应表中的列。

 候选码 ： 若关系中的某⼀属性或属性组的值能唯⼀的标识⼀个元组，⽽其任何、⼦集都不能再 标识，则称该属性组为候选码。例如：在学⽣实体中，“学号”是能唯⼀的区分学⽣实体的，同时 ⼜假设“姓名”、“班级”的属性组合⾜以区分学⽣实体，那么{学号}和{姓名，班级}都是候选码。 

主码 : 主码也叫主键。主码是从候选码中选出来的。 ⼀个实体集中只能有⼀个主码，但可以有 多个候选码。 

外码 : 外码也叫外键。如果⼀个关系中的⼀个属性是另外⼀个关系中的主码则这个属性为外码。 

主属性 ： 候选码中出现过的属性称为主属性。如果主码是⼀个属性组，那么属性组中的属性都是主属性。 

⾮主属性： 不包含在任何⼀个候选码中的属性称为⾮主属性

### 主键和外键有什么区别?

主键(主码) ：主键⽤于唯⼀标识⼀个元组，不能有重复，不允许为空。⼀个表只能有⼀个主键。 

外键(外码) ：外键⽤来和其他表建⽴联系⽤，外键是另⼀表的主键，外键是可以有重复的，可以 是空值。⼀个表可以有多个外键。

### 什么是 ER 图？

E-R 图 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的⽅法， ⽤来描述现实世界的概念模型。

### 数据库范式(待续)

1NF：属性不可再分。 

2NF：1NF 的基础之上，消除了⾮主属性对于码的部分函数依赖。 

3NF：3NF 在 2NF 的基础之上，消除了⾮主属性对于码的传递函数依赖 。

### 什么是存储过程?

存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行

存储过程难以调试和扩展，没有移植性

### drop、delete 与 truncate 区别？

drop table 表名，删除表

truncate table 表名 ，清空表数据，再插⼊数据的时⾃增⻓ id  从 1 开始

delete from 表名 where 列名=值 ，删除某⼀⾏的数据，如果不加 where ⼦ 句和 truncate table 表名 作⽤类似

delete、truncate删除表的数据，drop删除表的结构

### DML和DDL

DML(Data Manipulation Language)对表记录的insert、update、delete、select

DDL(Data Definition Language)定义关系模式、删除关系、修改关系模式以及创建数据库中的各种对象，比如表、聚簇、索引、视图、函数、存储过程和触发器等等

drop>truncate>delete

delete执行时产生日志，truncate将表的自增值重置和索引恢复初始大小

drop会把表占用空间释放

### 数据库设计通常分为哪⼏步?

1. 需求分析 : 分析⽤户的需求，包括数据、功能和性能需求。
2.  概念结构设计 : 主要采⽤ E-R 模型进⾏设计，包括画 E-R 图。 
3.  逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
4. 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。
5. 数据库实施 : 包括编程、测试和试运⾏
6. 数据库的运⾏和维护 : 系统的运⾏与数据库的⽇常维护。

## MySQL

### 关系型数据库

是⼀种建⽴在关系模型的基础上的数据库，关系模型表明了数据库中所存 储的数据之间的联系（⼀对⼀、⼀对多、多对多）

### MySQL存储引擎

5.5.5之前默认MyISAM，之后InnoDB

可以为不同的数据库表设置不 同的存储引擎以适应不同场景的需要，存储引擎是基于表的，⽽不是数据库。

|                                          | MyISAM                   | InnoDB             |
| ---------------------------------------- | ------------------------ | ------------------ |
| 是否支持行级锁                           | 表级锁，并导致发写性能低 | 行级锁             |
| 是否支持事务                             | 否                       | 是                 |
| 是否支持外键                             | 否                       | 是                 |
| 是否⽀持数据库异常崩溃后的安全恢复       | 否                       | 是                 |
| 是否支持MVCC(一种提高数据库并发性能技术) | 否                       | 是                 |
| 索引实现，都基于B+Tree                   | 数据文件本身是索引文件   | 索引文件与数据分离 |

### MySQL事务

事务用于保证数据的一致性

事务未说明指分布式事务往往指数据库事务，数据库事务可以保证多个对数据库的操作构成一个逻辑上的整体，遵循要么都执⾏，要么都不执⾏，是事务是逻辑上的⼀组操作。

#### 事务的ACID特性

- 原子性(Atomicity)，事务是最⼩的执⾏单位，不允许分割

- 一致性(Consistency)，执行事务前后数据保持一致
- 隔离性(isolation)，并发访问数据库时一个事务不被其他事务干扰
- 持久性(Durability)，一个事务被提交之后对数据库中数据改变时持久的

AID是手段，C是目的

### 并发事务带来了哪些问题?

- 脏读（Dirty read）: 当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提交 到数据库中，这时另外⼀个事务也访问了这个数据，然后使⽤了这个数据。因为这个数据是还没 有提交的数据，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是 不正确的。 
-  丢失修改（Lost to modify）: 指在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数据， 那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事务内的修 改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。 
- 不可重复读（Unrepeatable read）: 指在⼀个事务内多次读同⼀数据。在这个事务还没有结束 时，另⼀个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修 改导致第⼀个事务两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不 ⼀样的情况，因此称为不可重复读。 
- 幻读（Phantom read）: 幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据， 接着另⼀个并发事务（T2）插⼊了⼀些数据时。在随后的查询中，第⼀个事务（T1）就会发现 多了⼀些原本不存在的记录，就好像发⽣了幻觉⼀样，所以称为幻读。

#### 不可重复读和幻读有什么区别呢？

不可重复读的重点是内容修改或者记录减少⽐如多次读取⼀条记录发现其中某些记录的值被修 改； 幻读的重点在于记录新增⽐如多次执⾏同⼀条查询语句（DQL）时，发现查到的记录增加了。 幻读其实可以看作是不可重复读的⼀种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复 读的⽅案不⼀样。

#### SQL 标准定义了哪些事务隔离级别?（待续）

- READ-UNCOMMITTED(读取未提交) ： 最低的隔离级别，允许读取尚未提交的数据变更，可能 会导致脏读、幻读或不可重复读。 
- READ-COMMITTED(读取已提交) ： 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是 幻读或不可重复读仍有可能发⽣。 
- REPEATABLE-READ(可重复读) ： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本 身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 
- SERIALIZABLE(可串⾏化) ： 最⾼的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次 逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读 以及幻读。

#### MySQL 的隔离级别是基于锁实现的吗？

SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都 是基于 MVCC 实现。

#### MySQL 的默认隔离级别是什么?

MySQL InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重读）

### MySQL锁

#### 表级锁和⾏级锁了解吗？有什么区别？

MyISAM 仅仅⽀持表级锁(table-level locking)，是MySQL 中锁定粒度最⼤的⼀种锁，这在并发写的情况下性⾮常差。 InnoDB 不光⽀持表级锁(table-level locking)，还⽀持⾏级锁(row-level locking)，默认为⾏级锁。⾏ 级锁的粒度最⼩，仅对相关的记录上锁即可（对⼀⾏或者多⾏记录加锁），并发度⾼，但加锁的开销 也最⼤，加锁慢，会出现死锁。

#### ⾏级锁的使⽤有什么注意事项？

InnoDB 的⾏锁是针对索引字段加的锁，表级锁是针对⾮索引字段加的锁。当我们执⾏ UPDATE 、 DELETE 语句时，如果 WHERE 条件中字段没有命中唯⼀索引（如主键索引）或者索引失效的话，就 会导致扫描全表对表中的所有⾏记录进⾏加锁

#### 共享锁和排他锁(待续，没看懂)

## Redis

### 简介

一个使用c语言开发的数据库，是内存数据库，读写速度非常快，被广泛用于缓存方向

### 为什么要⽤ Redis/为什么要⽤缓存？

高性能：先判断要请求的数据是否存在于缓存中，存在直接从缓存中取出返回，不存在则访问数据库，并且数据是高频访问数据将其放入缓存

**QPS(Query Per Second)：服务器每秒可以执行的查询次数**

高并发：提高QPS，提高了系统整体的并发

### Redis除了做缓存，还能做什么？

分布式锁（基于Redisson）、限流（Redis+Lua）、消息队列、复杂业务场景

### Redis数据结构

#### Redis常用的数据结构

5种基础数据结构：String，List，Set，Hash，Zset

3种特殊数据结构：HyperLogLogs（基数统计）、Bitmap（位存储）、Geospatial（地理位置）

#### String的应用场景

常规数据如session、token、序列化后的对象的缓存

计数如用户单位时间的请求数（简单限流），页面单位时间访问数

分布式锁

#### String还是Hash存储对象数据更好？

String存储的是序列化后的对象数据，存放整个对象，Hash是对对象的每个字段单独存储，可以获取，修改，添加字段，对象中某些字段经常变动或查询可以使用hash，String存储节省内存，缓存相同数量数据消耗内存是Hash的一半，购物车用hash，用户id为key，商品id为field，商品数量为value

#### 如何使用Redis实现一个排行榜

sorted set常用于排行榜

#### 如何使用set实现抽奖系统（待续）

### Redis内存管理

#### 为什么要给Redis 缓存数据设置过期时间

内存有限，缓解内存的消耗

#### 过期数据的删除策略

惰性删除：取出key时对数据进行过期检查，对cpu友好但可能造成过多key未删除

定期删除：每隔一段时间抽取key执行删除过期key操作，对内存友好

因此Redis采用定期删除+惰性删除

#### Redis内存淘汰机制

设置过期时间仍可能存在大量过期key堆积，采用内存淘汰机制解决

volatile-lru(last recently used)：从已设置过期数据集中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期数据集中挑选将要过期的数据淘汰

volatile-random：从已设置过期数据集中随机挑选数据淘汰

allkeys-lru：当内存不足以容纳新写入的数据时，在键空间中移除最近最少使用的key，最常用

allkeys-random：从数据集中任意选择数据淘汰

no-eviction：内存不足时新写入操作报错

volatile-lfu(least frequently used)：：从已设置过期时间的数据集中 挑选最不经常使⽤的数据淘汰

allkeys-lfu：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最 不经常使⽤的 key

### Redis持久化机制

#### 怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复？

持久化数据，快照(snapshotting，RDB)，只追加文件(append-only file，AOF)

#### 什么是RDB持久化

创建快照来获得存储在内存里面的数据在某个时间点上的副本，可以用于创建相同数据的服务器副本和重启服务器时使用

Redis默认采用的持久化方式

#### RDB 创建快照时会阻塞主线程吗？

save主线程执行，会阻塞主线程

bgsave子线程执行，不会阻塞主线程，默认选项

#### 什么是AOF持久化

相对于RDB实时性更好，已成为主流，redis默认未开启

```
appendfsync always #每次有数据修改发⽣时都会写⼊AOF⽂件,这样会严重降低Redis的速度
appendfsync everysec #每秒钟同步⼀次，显式地将多个写命令同步到硬盘
appendfsync no #让操作系统决定何时进⾏同步
```

#### AOF日志是如何实现的

关系数据库如MySQL通常是执行命令前记录日志，方便故障恢复，Redis AOF持久化机制是在执行命令后记录日志

优点：避免额外的检查开销，AOF记录日志不会对命令进行语法检查，不会阻塞当前命令执行

缺点：刚执行完命令redis宕机会导致修改丢失，AOF记录日志在主线程进行，可能阻塞后续其他命令执行

#### AOF重写

可以产生一个数据相同但更小的AOF文件，在执行BGRWRITEAOF时Redis会维护一个AOF重写缓冲区，创建新文件期间会记录所有写命令，创建完成后追加到AOF文件末尾，然后替换旧的AOF文件

#### Redis 4.0 对于持久化机制做了什么优化？

开始支持RDB和ROF混合持久化，默认关闭，打开时AOF重写会把RDB内容写到AOF文件开头，可以结合RDB和AOF优点，快速加载同时避免丢失过多数据，AOF里的RDB部分不是AOF可读性较差

### Redis事务

