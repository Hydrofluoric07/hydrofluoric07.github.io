---
title: Java基础面试题
date: 2024-09-09 20:05:56 +0800
categories: [blog, java]
tags: [java, note, 面试]     # TAG names should always be lowercase
typora-root-url: ./..
---
## Java基础(上)

### JVM vs JDK vs JRE

JVM是运⾏ Java 字节码的虚拟机，是 Java 语言“⼀次编译，随处可以运⾏”的关键所在。

JDK( Java Development Kit)包括JRE，javac，javadoc，jdb

JRE 是 Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机 （JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序

### 什么是字节码?采用字节码的好处是什么?

JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的⽂件），⼀定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点

![java-to-source](/assets/img/2024-9-9-java-basic-interview/java-to-source.png)

### 为什么说 Java 语言“编译与解释并存“？

Java 语言被称为“编译与解释并存”的原因是它在执行过程中同时使用了编译和解释两种方式。

-   **编译**: 源代码会经过编译器（javac）将其转换成字节码文件（.class），这个过程就是编译。编译后的字节码文件可以在任何支持 Java 虚拟机（JVM）的平台上运行。     
-   **解释**: 当 Java 程序运行时，Java 虚拟机会对字节码进行解释或即时编译为机器码再执行。解释执行是逐条解释执行字节码指令，而即时编译则是将热点代码（经常执行的代码）编译成本地机器码，以提高执行效率。   

### Java 语言关键字有哪些？

虽然 true , false , 和 null 看起来像关键字但实际上他们是字面值

### 成员变量与局部变量的区别？

**语法形式** ：成员变量是属于类的，⽽局部变量是在代码块或⽅法中定义的变 量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不 能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 

**存储方式** ：如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。⽽对象存在于堆 内存，局部变量则存在于栈内存。 

**生存时间** ：成员变量是对象的⼀部分，它随着对象的创建⽽ 存在，⽽局部变量随着⽅法的调⽤⽽⾃动⽣成，随着⽅法的调⽤结束⽽消亡。

 **默认值** ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会⾃动以类型的默认值 ⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动 赋值。

### 静态变量有什么作⽤？

静态变量可以被类的所有实例共享。⽆论⼀个类创建了多少个对象，它们都共享同⼀份静态变量。 通常情况下，静态变量会被 final 关键字修饰成为常量。

### 字符型常量和字符串常量的区别? 

形式 : 字符常量是单引号引起的⼀个字符，字符串常量是双引号引起的 0 个或若⼲个字符。

 字符常量相当于⼀个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表⼀个地址值 (该字符串在内存中存放位置)。

 占内存⼤⼩ ： 字符常量只占 2 个字节; 字符串常量占若⼲个字节。

### 静态⽅法和实例⽅法有何不同？

1、调⽤⽅式

实例方法使用对象名.方法名来调用，静态方法还可以使用类名.方法名调用，静态⽅法不属于类的某个对象⽽是属于这个类，⼀般建议使⽤ 类名.⽅法名

2、访问类成员是否存在限制

静态⽅法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态⽅法），不允许访问实 例成员（即实例成员变量和实例⽅法），⽽实例⽅法不存在这个限制。

### 重载和重写的区别

重载是同⼀个类中多个同名⽅法根据不同的传参来执⾏不同的逻辑处理，重写是子类继承父类方法时覆盖父类方法

发⽣在同⼀个类中（或者⽗类和⼦类之间），⽅法名必须相同，参数类型不同、个数不同、顺序不 同，⽅法返回值和访问修饰符可以不同。

⽅法的重写要遵循“两同两⼩⼀⼤”： “两同”即⽅法名相同、形参列表相同； “两⼩”指的是⼦类⽅法返回值类型应⽐⽗类⽅法返回值类型更⼩或相等，⼦类⽅法声明抛出的异 常类应⽐⽗类⽅法声明抛出的异常类更⼩或相等； “⼀⼤”指的是⼦类⽅法的访问权限应⽐⽗类⽅法的访问权限更⼤或相等。

![overload&override.png](/assets/img/2024-9-9-java-basic-interview/overload&override.png)

### 什么是可变长参数

允许在调⽤⽅法时传⼊不定⻓度的 参数，只能作为函数的最后⼀个参数

方法重载时会优先匹配固定参数的方法

### Java基本数据类型

![java-data-type](/assets/img/2024-9-9-java-basic-interview/java-data-type.png)

### 基本类型和包装类型的区别？

成员变量包装类型不赋值就是 null ，⽽基本类型有默认值且不是 null 。 

包装类型可⽤于泛型，⽽基本类型不可以。 

基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量 （未被 static 修饰 ）存放在 Java 虚拟机的堆中。

包装类型属于对象类型，我们知道⼏乎所有 对象实例都存在于堆中。 相⽐于对象类型， 基本数据类型占⽤的空间⾮常⼩。

![basic-type-wrapper](/assets/img/2024-9-9-java-basic-interview/basic-type-wrapper.png)

```java
Integer i1=40;
Integer i2=new Integer(40);
System.out.println(i1==i2);
```

Integer i1=40 这⼀⾏代码会发⽣装箱，也就是说这⾏代码等价于 Integer i1=Integer.valueOf(40) 。因 此， i1 直接使⽤的是缓存中的对象。⽽ Integer i2 = new Integer(40) 会直接创建新的对象，答案是false。

Float,Double没有实现缓存机制

### ⾃动装箱与拆箱了解吗？原理是什么？

装箱：将基本类型⽤它们对应的引⽤类型包装起来； 

拆箱：将包装类型转换为基本数据类型；

现装箱其实就是调⽤了 包装类的 valueOf() ⽅法，拆箱其实就是调⽤了 xxxValue() ⽅法。

### 如何解决浮点数运算的精度丢失问题？

BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，⼤部分需要浮点数精确运 算结果的业务场景（⽐如涉及到钱的场景）都是通过 BigDecimal 来做的。

### 超过 long 整型的数据应该如何表示？

BigInteger 内部使⽤ int[] 数组来存储任意⼤⼩的整形数据。 相对于常规整数类型的运算来说， BigInteger 运算的效率会相对᫾低。

### 如果⼀个类没有声明构造⽅法，该程序能正确执⾏吗?

⼀个类没有声明构造⽅法也会有默认的不带参数的构造⽅法。如果我们⾃⼰添加了类的构造⽅法（⽆论是否有参），Java 就不会再添加默认的⽆ 参数的构造⽅法了。如果我们重载了有参的构造⽅法，建议把⽆参的 构造⽅法也写出来（⽆论是否⽤到），因为这可以帮助我们在创建对象的时候少踩坑。

### 构造⽅法有哪些特点？是否可被 override?

名字与类名相同。 没有返回值，但不能⽤ void 声明构造函数。 ⽣成类的对象时⾃动执⾏，⽆需调⽤。

 构造⽅法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造 函数的情况。

## Java基础(中)

### 面向对象三大特征

封装是指把⼀个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内 部信息

通过使⽤继承，可以快速地创建新的类，可以提⾼代码的重⽤，程序的可维护性，节省⼤ 量创建新类的时间 ，提⾼开发效率。⼦类拥有⽗类对象所有的属性和⽅法（包括私有属性和私有⽅法），但是⽗类中的私有属性和⽅ 法⼦类是⽆法访问，只是拥有。 ⼦类可以拥有⾃⼰属性和⽅法，即⼦类可以对⽗类进⾏扩展。 ⼦类可以⽤⾃⼰的⽅式实现⽗类的⽅法。

多态：*同一个方法在不同的对象上执行会产生不同的结果。*三个必要条件：继承、重写、父类引用指向子类对象：Parent p=new Child();

### 接口和抽象类区别

1. 抽象类不能被实例化
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体。
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

共同点 ： 都**不能被实例化**。 **都可以包含抽象⽅法**。 都可以有默认实现的⽅法（Java 8 可以⽤ default 关键字在接⼝中定义默认⽅法）。

 区别 ： 接⼝主要⽤于对类的⾏为进⾏约束，你实现了某个接⼝就具有了对应的⾏为。抽象类主要⽤于代 码复⽤，强调的是所属关系。 ⼀个类只能继承⼀个类，但是可以实现多个接⼝。 接⼝中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，⽽抽象类的 成员变量默认 default，可在⼦类中被重新定义，也可被重新赋值。

### 深拷⻉和浅拷⻉区别了解吗？什么是引⽤拷⻉？

浅拷⻉会在堆上创建⼀个新的对象（区别于引⽤拷⻉的⼀点），如果原对象内部 的属性是引⽤类型的话，浅拷⻉会直接复制内部对象的引⽤地址，也就是说拷⻉对象和原对象共 ⽤同⼀个内部对象。 深拷⻉会完全复制整个对象，包括这个对象所包含的内部对象。

引⽤拷⻉就是两个不同的引⽤指向同⼀个对象

![java-clone](/C:/Users/admin/AppData/Roaming/Typora/typora-user-images/java-clone.png)

### == 和 equals() 的区别

对于基本数据类型来说， == 比较的是值。 对于引⽤数据类型来说， == 比较的是对象的内存地址。因为 Java 只有值传递，所以，对于 == 来说，不管是⽐᫾基本数据类型，还是引⽤数据类型的 变量，其本质⽐᫾的都是值，只是引⽤类型变量存的值是对象的地址。

因为 Java 只有值传递，所以，对于 == 来说，不管是⽐᫾基本数据类型，还是引⽤数据类型的 变量，其本质⽐᫾的都是值，只是引⽤类型变量存的值是对象的地址。

```java
public boolean equals(Object obj){
    return (this==obj);
}
```



equals() ⽅法存在两种使⽤情况： 类没有重写 equals() ⽅法 ：通过 equals() ⽐᫾该类的两个对象时，等价于通过“==”⽐᫾这两个 对象，使⽤的默认是 Object 类 equals() ⽅法。 类重写了 equals() ⽅法 ：⼀般我们都重写 equals() ⽅法来⽐较两个对象中的属性是否相等； 若它们的属性相等，则返回 true(即，认为这两个对象相等)。
