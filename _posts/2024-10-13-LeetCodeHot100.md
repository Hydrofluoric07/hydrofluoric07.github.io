---
title: LeetCodeHot100
date: 2024-10-13 20:03:25 +0800
categories: [interview, algorithm]
tags: [interview, algorithm]     # TAG names should always be lowercase
typora-root-url: ./..
---

## 矩阵

### [旋转图像](https://leetcode.cn/problems/rotate-image/)

思路：上下对称互换换位置，再以对角线互换位置

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[n-1-i][j];
                matrix[n-1-i][j]=tmp;
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){        //需要注意此处为j<i
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=tmp;
            }
        }
    }
}
```

### [搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

思路：遍历每个数组元素，进行二分搜索

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for(int[] rows:matrix){
            int index=binarySearch(rows,target);
            if(index>=0&&index<rows.length&&rows[index]==target)return true;
        }
        return false;
    }

    public int binarySearch(int[] nums, int target) {		//第一个大于等于target位置的下标
        int l = 0, r = nums.length;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] < target) {
                l = mid + 1;
            } else
                r = mid;
        }
        return l;
    }
}
```

## 技巧

### [下一个排列](https://leetcode.cn/problems/next-permutation/)

先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。

如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为 a[j]。

交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。

思路：从后往前找一个顺序对[i,i+1]，交换位置才有意义数字变大，然后再从后找第一个比nums[i]大的数nums[j]交换，变大的要尽可能少所以从后往前找，再反转[i+1,n)，交换后[i+1,n)一定是降序的所有把它变成顺序的

```java
//记忆：从后往前找一个顺序对[i,i+1]，再从后找第一个数nums[j]使nums[j]>nums[i]，反转[i+1,n)
class Solution {
    public void nextPermutation(int[] nums) {
        int i=nums.length-2;
        while(i>=0&&nums[i]>=nums[i+1]){
            i--;
        }
        if(i>=0){
            int j=nums.length-1;
            while(j>=0&&nums[i]>=nums[j]){
                j--;
            }
            swap(nums,i,j);
        }
        reverse(nums,i+1);
    }
    public void swap(int[] nums,int i,int j){
        int tmp=nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
    }
    public void reverse(int[] nums,int start){
        int left=start,right=nums.length-1;
        while(left<right){
            swap(nums,left,right);
            left++;right--;
        }
    }
    // 1 5 8 (4) 7 6 (5) 3 1
    // 1 5 8 5 7 6 4 3 1
    // 1 5 8 5 1 3 4 6 7
}
```

