---
title: LeetCodeHot100
date: 2024-10-13 20:03:25 +0800
categories: [interview, algorithm]
tags: [interview, algorithm]     # TAG names should always be lowercase
typora-root-url: ./..
---

## 矩阵

### [旋转图像](https://leetcode.cn/problems/rotate-image/)

思路：上下对称互换换位置，再以对角线互换位置

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[n-1-i][j];
                matrix[n-1-i][j]=tmp;
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){        //需要注意此处为j<i
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=tmp;
            }
        }
    }
}
```

### [搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

思路：遍历每个数组元素，进行二分搜索

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for(int[] rows:matrix){
            int index=binarySearch(rows,target);
            if(index>=0&&index<rows.length&&rows[index]==target)return true;
        }
        return false;
    }

    public int binarySearch(int[] nums, int target) {		//第一个大于等于target位置的下标
        int l = 0, r = nums.length;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] < target) {
                l = mid + 1;
            } else
                r = mid;
        }
        return l;
    }
}
```

## 图论

### [岛屿数量](https://leetcode.cn/problems/number-of-islands/)

思路：使用vis数组记录是否访问，遍历若是岛屿且未访问过则将整个岛屿扩展为访问过

```java
class Solution {
    int[] dx=new int[]{0,1,0,-1},dy=new int[]{1,0,-1,0};
    int ans=0;
    int n,m;boolean[][] vis;
    public int numIslands(char[][] grid) {
        this.n=grid.length;this.m=grid[0].length;
        this.vis=new boolean[n][m];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]=='1'&&!vis[i][j]){
                    dfs(i,j,grid);
                    ans++;
                }
            }
        }
        return ans;
    }
    public void dfs(int x,int y,char[][] grid){
        vis[x][y]=true;
        for(int i=0;i<4;i++){
            int tx=x+dx[i],ty=y+dy[i];
            if(tx>=0&&tx<n&&ty>=0&&ty<m&&!vis[tx][ty]&&grid[tx][ty]=='1'){
                dfs(tx,ty,grid);
            }
        }
    }
}
```

### [腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

思路：广度优先搜索

```java
class Solution{
    int n,m;
    int[] dx=new int[]{0,1,0,-1},dy=new int[]{1,0,-1,0};
    int[][] ans;
    public int orangesRotting(int[][] grid) {
        this.n=grid.length;this.m=grid[0].length;
        ans=new int[n][m];
        for(int[] i:ans){
            Arrays.fill(i,Integer.MAX_VALUE);
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==2){
                    Deque<Point> q=new LinkedList<>();
                    q.addFirst(new Point(i, j));
                    boolean[][] vis=new boolean[n][m];
                    vis[i][j]=true;
                    int depth=0;
                    while(!q.isEmpty()){
                        int size=q.size();
                        for(int k=0;k<size;k++){
                            Point p=q.pollLast();
                            ans[p.x][p.y]=Math.min(ans[p.x][p.y],depth);
                            vis[p.x][p.y]=true;
                            for(int g=0;g<4;g++){
                                int tx=p.x+dx[g],ty=p.y+dy[g];
                                if(tx>=0&&tx<n&&ty>=0&&ty<m&&grid[tx][ty]==1&&!vis[tx][ty]){
                                    q.addFirst(new Point(tx, ty));
                                }
                            }
                        }
                        depth++;
                    }
                }
            }
        }
        int res=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==1){
                    if(ans[i][j]==Integer.MAX_VALUE)return -1;
                    else res=Math.max(res,ans[i][j]);
                }
            }
        }
        return res;
    }
}
class Point{
    int x;int y;
    public Point(int x,int y){
        this.x=x;this.y=y;
    }
}
```

### [课程表](https://leetcode.cn/problems/course-schedule/)

思路：建图，套用拓扑排序

拓扑排序：

核心：维持一个入度为0的集合

S装着所有入度为0的点，L是一个空列表

每次从S中取出一个点u放入L，然后将u的所有出边删除，若删除后边(u,v)的点v入度为0，则放入S中，直到S为空，若L.size()==n点数，则该图是一个DAG

```java
class Solution {
    int[] in=new int[2001];
    List<Integer>[] G=new ArrayList[2001];
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        for(int[] num:prerequisites){
            int u=num[0],v=num[1];
            in[v]++;
            G[u] = G[u] == null ? new ArrayList<>() : G[u];
            G[u].add(v);
        }
        return toposort(numCourses);
    }
    public boolean toposort(int numCourses){
        List<Integer> L=new ArrayList<>();
        Deque<Integer> S=new LinkedList<>();
        for(int i=0;i<numCourses;i++){
            if(in[i]==0){
                S.addFirst(i);
            }
        }
        while(!S.isEmpty()){
            int u=S.pollLast();
            L.add(u);
            if(G[u]!=null){
                for(int v:G[u]){
                    if(--in[v]==0){
                        S.addFirst(v);
                    }
                }
            }

        }
        return L.size()==numCourses;
    }
}
```

### [实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

![image-20241016212331712](/assets/img/2024-10-13-LeetCodeHot100/image-20241016212331712.png)

```java
class Trie {
    int[][] nex=new int[100001][26];
    int idx=0;
    boolean[] exists=new boolean[100001];
    public Trie() {

    }
    
    public void insert(String word) {
        int p=0;
        for(int i=0;i<word.length();i++){
            int c=word.charAt(i)-'a';
            if(nex[p][c]==0)nex[p][c]=++idx;
            p=nex[p][c];
        }
        exists[p]=true;		//注意不能遗漏
    }
    
    public boolean search(String word) {
        int p=0;
        for(int i=0;i<word.length();i++){
            int c=word.charAt(i)-'a';
            if(nex[p][c]==0)return false;
            p=nex[p][c];
        }
        return exists[p];
    }
    
    public boolean startsWith(String prefix) {
         int p = 0;
        for (int i = 0; i < prefix.length(); i++) {
            int c = prefix.charAt(i) - 'a';
            if (nex[p][c] == 0) return false; // No such prefix
            p = nex[p][c];
        }
        return true;
    }
}
```



## 哈希

### [两数之和](https://leetcode.cn/problems/two-sum/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> mp=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            Integer tmp=mp.get(target-nums[i]);
            if(tmp!=null){
                return new int[]{i,tmp};
            }
            mp.put(nums[i],i);
        }
        return new int[2];
    }
}
```

### [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> mp = new HashMap<>();
        for (String str : strs) {
            char[] ch = str.toCharArray();
            Arrays.sort(ch);
            String key = new String(ch);
            List<String> list = mp.getOrDefault(key, new ArrayList<>());
            list.add(str);
            mp.put(key, list);
        }
        List<List<String>> ans = new ArrayList<>();
        for (List<String> list : mp.values()) {
            ans.add(list);
        }
        return ans;
    }
}
```

### [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

思路：前缀和+哈希，注意需要mp.put(0,1)

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int ans=0,pre=0;
        Map<Integer,Integer> mp=new HashMap<>();
        mp.put(0,1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            ans+=mp.getOrDefault(pre-k,0);
            mp.put(pre,mp.getOrDefault(pre,0)+1);
        }
        return ans;
    }
}
```

### [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        int ans=0;
        Set<Integer> st=new HashSet<>();
        for(int i:nums)st.add(i);
        for(int i:nums){
            if(!st.contains(i-1)){
                int cur=i;
                while(st.contains(cur+1)){
                    cur++;
                }
                ans=Math.max(ans,cur-i+1);
            }
        }
        return ans;
    }
}
```



## 双指针

### [移动零](https://leetcode.cn/problems/move-zeroes/)

思路：L指向已经处理好的尾部（不包括），R指向待处理头部（包括），右指针右移如果非零就交换，左指针右移

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int L=0,R=0;
        while(R<nums.length){
            if(nums[R]!=0){
                swap(nums,L,R);
                L++;
            }
            R++;
        }
    }
    public void swap(int[] nums,int p,int q){
        int tmp=nums[p];
        nums[p]=nums[q];
        nums[q]=tmp;
    }
}
```

### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

思路：初始化L=0，R=n-1，向内移动短板可能变大，向内移动长板一定变小

记忆：初始化L=0，R=n-1，矮的向中间靠拢

![image-20241014200003517](/assets/img/2024-10-13-LeetCodeHot100/image-20241014200003517.png)

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

### [三数之和](https://leetcode.cn/problems/3sum/)

思路：排序，枚举时再双指针，注意两次检查是否与前一个数相同

记忆：排序，两次for，检查两次

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n=nums.length;
        List<List<Integer>> ans=new ArrayList<>();
        for(int i=0;i<n-2;i++){
            int r=n-1;
            //要和上一次枚举的数不同
            if(i>0&&nums[i]==nums[i-1])continue;
            int target=-nums[i];
            for(int j=i+1;j<n;j++){//再来一次for循环，要对左端点进行枚举
                if(j>i+1&&nums[j]==nums[j-1])continue;
                while(j<r&&nums[j]+nums[r]>target)r--;
                if(j==r)break;//重合了就退出
                if(nums[j]+nums[r]==target){
                    ans.add(List.of(nums[i],nums[j],nums[r]));
                }
            }
        }
        return ans;
    }
}
```

### [接雨水(单调栈做法)](https://leetcode.cn/problems/trapping-rain-water/)

![image-20241014204429544](/assets/img/2024-10-13-LeetCodeHot100/image-20241014204429544.png)

思路：横着计算，面积由当前元素（放入栈中打破单调严格递减的元素）下标，栈顶元素下标、栈顶下的元素下标决定，若栈顶元素出栈后栈为空则退出，否则计算答案并累加

思路：维护一个单调不增的单调栈，栈里有两个元素就取出一个作为然后高度减去它，累加

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        int n = height.length;
        for (int i = 0; i < n; ++i) {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int top = stack.pop();
                if (stack.isEmpty()) {
                    break;
                }
                int left = stack.peek();
                int currWidth = i - left - 1;
                int currHeight = Math.min(height[left], height[i]) - height[top];
                ans += currWidth * currHeight;
            }
            stack.push(i);
        }
        return ans;
    }
}
```



## 技巧

### [下一个排列](https://leetcode.cn/problems/next-permutation/)

先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。

如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为 a[j]。

交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。

思路：从后往前找一个顺序对[i,i+1]，交换位置才有意义数字变大，然后再从后找第一个比nums[i]大的数nums[j]交换，变大的要尽可能少所以从后往前找，再反转[i+1,n)，交换后[i+1,n)一定是降序的所有把它变成顺序的

```java
//记忆：从后往前找一个顺序对[i,i+1]，再从后找第一个数nums[j]使nums[j]>nums[i]，反转[i+1,n)
class Solution {
    public void nextPermutation(int[] nums) {
        int i=nums.length-2;
        while(i>=0&&nums[i]>=nums[i+1]){
            i--;
        }
        if(i>=0){
            int j=nums.length-1;
            while(j>=0&&nums[i]>=nums[j]){
                j--;
            }
            swap(nums,i,j);
        }
        reverse(nums,i+1);
    }
    public void swap(int[] nums,int i,int j){
        int tmp=nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
    }
    public void reverse(int[] nums,int start){
        int left=start,right=nums.length-1;
        while(left<right){
            swap(nums,left,right);
            left++;right--;
        }
    }
    // 1 5 8 (4) 7 6 (5) 3 1
    // 1 5 8 5 7 6 4 3 1
    // 1 5 8 5 1 3 4 6 7
}
```

