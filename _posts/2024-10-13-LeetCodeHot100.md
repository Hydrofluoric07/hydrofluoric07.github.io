---
title: LeetCodeHot100
date: 2024-10-13 20:03:25 +0800
categories: [interview, algorithm]
tags: [interview, algorithm]     # TAG names should always be lowercase
typora-root-url: ./..
---

## 矩阵

### [旋转图像](https://leetcode.cn/problems/rotate-image/)

思路：上下对称互换换位置，再以对角线互换位置

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[n-1-i][j];
                matrix[n-1-i][j]=tmp;
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){        //需要注意此处为j<i
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=tmp;
            }
        }
    }
}
```

### [搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

思路：遍历每个数组元素，进行二分搜索

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for(int[] rows:matrix){
            int index=binarySearch(rows,target);
            if(index>=0&&index<rows.length&&rows[index]==target)return true;
        }
        return false;
    }

    public int binarySearch(int[] nums, int target) {		//第一个大于等于target位置的下标
        int l = 0, r = nums.length;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] < target) {
                l = mid + 1;
            } else
                r = mid;
        }
        return l;
    }
}
```

## 哈希

### [两数之和](https://leetcode.cn/problems/two-sum/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> mp=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            Integer tmp=mp.get(target-nums[i]);
            if(tmp!=null){
                return new int[]{i,tmp};
            }
            mp.put(nums[i],i);
        }
        return new int[2];
    }
}
```

### [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> mp = new HashMap<>();
        for (String str : strs) {
            char[] ch = str.toCharArray();
            Arrays.sort(ch);
            String key = new String(ch);
            List<String> list = mp.getOrDefault(key, new ArrayList<>());
            list.add(str);
            mp.put(key, list);
        }
        List<List<String>> ans = new ArrayList<>();
        for (List<String> list : mp.values()) {
            ans.add(list);
        }
        return ans;
    }
}
```

### [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

思路：前缀和+哈希，注意需要mp.put(0,1)

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int ans=0,pre=0;
        Map<Integer,Integer> mp=new HashMap<>();
        mp.put(0,1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            ans+=mp.getOrDefault(pre-k,0);
            mp.put(pre,mp.getOrDefault(pre,0)+1);
        }
        return ans;
    }
}
```

### [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        int ans=0;
        Set<Integer> st=new HashSet<>();
        for(int i:nums)st.add(i);
        for(int i:nums){
            if(!st.contains(i-1)){
                int cur=i;
                while(st.contains(cur+1)){
                    cur++;
                }
                ans=Math.max(ans,cur-i+1);
            }
        }
        return ans;
    }
}
```



## 双指针

### [移动零](https://leetcode.cn/problems/move-zeroes/)

思路：L指向已经处理好的尾部（不包括），R指向待处理头部（包括），右指针右移如果非零就交换，左指针右移

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int L=0,R=0;
        while(R<nums.length){
            if(nums[R]!=0){
                swap(nums,L,R);
                L++;
            }
            R++;
        }
    }
    public void swap(int[] nums,int p,int q){
        int tmp=nums[p];
        nums[p]=nums[q];
        nums[q]=tmp;
    }
}
```

### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

思路：初始化L=0，R=n-1，向内移动短板可能变大，向内移动长板一定变小

记忆：初始化L=0，R=n-1，矮的向中间靠拢

![image-20241014200003517](/assets/img/2024-10-13-LeetCodeHot100/image-20241014200003517.png)

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

### [三数之和](https://leetcode.cn/problems/3sum/)

思路：排序，枚举时再双指针，注意两次检查是否与前一个数相同

记忆：排序，两次for，检查两次

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n=nums.length;
        List<List<Integer>> ans=new ArrayList<>();
        for(int i=0;i<n-2;i++){
            int r=n-1;
            //要和上一次枚举的数不同
            if(i>0&&nums[i]==nums[i-1])continue;
            int target=-nums[i];
            for(int j=i+1;j<n;j++){//再来一次for循环，要对左端点进行枚举
                if(j>i+1&&nums[j]==nums[j-1])continue;
                while(j<r&&nums[j]+nums[r]>target)r--;
                if(j==r)break;//重合了就退出
                if(nums[j]+nums[r]==target){
                    ans.add(List.of(nums[i],nums[j],nums[r]));
                }
            }
        }
        return ans;
    }
}
```

### [接雨水(单调栈做法)](https://leetcode.cn/problems/trapping-rain-water/)

![image-20241014204429544](/assets/img/2024-10-13-LeetCodeHot100/image-20241014204429544.png)

思路：横着计算，面积由当前元素（放入栈中打破单调严格递减的元素）下标，栈顶元素下标、栈顶下的元素下标决定，若栈顶元素出栈后栈为空则退出，否则计算答案并累加

思路：维护一个单调不增的单调栈，栈里有两个元素就取出一个作为然后高度减去它，累加

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        int n = height.length;
        for (int i = 0; i < n; ++i) {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int top = stack.pop();
                if (stack.isEmpty()) {
                    break;
                }
                int left = stack.peek();
                int currWidth = i - left - 1;
                int currHeight = Math.min(height[left], height[i]) - height[top];
                ans += currWidth * currHeight;
            }
            stack.push(i);
        }
        return ans;
    }
}
```



## 技巧

### [下一个排列](https://leetcode.cn/problems/next-permutation/)

先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。

如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为 a[j]。

交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。

思路：从后往前找一个顺序对[i,i+1]，交换位置才有意义数字变大，然后再从后找第一个比nums[i]大的数nums[j]交换，变大的要尽可能少所以从后往前找，再反转[i+1,n)，交换后[i+1,n)一定是降序的所有把它变成顺序的

```java
//记忆：从后往前找一个顺序对[i,i+1]，再从后找第一个数nums[j]使nums[j]>nums[i]，反转[i+1,n)
class Solution {
    public void nextPermutation(int[] nums) {
        int i=nums.length-2;
        while(i>=0&&nums[i]>=nums[i+1]){
            i--;
        }
        if(i>=0){
            int j=nums.length-1;
            while(j>=0&&nums[i]>=nums[j]){
                j--;
            }
            swap(nums,i,j);
        }
        reverse(nums,i+1);
    }
    public void swap(int[] nums,int i,int j){
        int tmp=nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
    }
    public void reverse(int[] nums,int start){
        int left=start,right=nums.length-1;
        while(left<right){
            swap(nums,left,right);
            left++;right--;
        }
    }
    // 1 5 8 (4) 7 6 (5) 3 1
    // 1 5 8 5 7 6 4 3 1
    // 1 5 8 5 1 3 4 6 7
}
```

