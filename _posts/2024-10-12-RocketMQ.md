---
title: RockerMQ笔记
date: 2024-10-09 18:26:04 +0800
categories: [note, RockerMQ]
tags: [note, RockerMQ]     # TAG names should always be lowercase
typora-root-url: ./..
typora-copy-images-to: ./..\assets\img\2024-10-12-RockerMQ
---

## MQ概述

![image-20241013080424105](/assets/img/2024-10-12-RockerMQ/image-20241013080424105.png)

优点：

1. 应用解耦：消费者是否存活不影响生产者，提高系统容错性和可维护性
2. 异步提速：生产方发送完消息可以进行下一步逻辑，提升系统吞吐量
3. 削峰填谷：可提高系统稳定性

缺点：

1.  可用性降低：外部依赖越多，稳定性越差，MQ宕机会对业务造成影响。如何保证MQ的高可用
2. 复杂度提高：如何保证消息没有重复消费，处理消息丢失，保证消息传递顺序性
3. 一致性、丢失、重复使用问题

![image-20241013082104992](/assets/img/2024-9-7-MySQL/image-20241013082104992.png)

## 工作原理

![image-20241013083352651](/assets/img/2024-9-7-MySQL/image-20241013083352651.png)

## 安装

略

## 消息发送

```java
public class Consumer {
    public static void main(String[] args) throws Exception {
        /**
         1. 谁来发？
         2. 发给谁？
         3. 怎么发？
         4. 发什么？
         5. 发的结果是什么？
         6. 打扫战场
         **/

        //1.创建一个接收消息的对象Consumer
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("group1");
        //2.设定接收的命名服务器地址
        consumer.setNamesrvAddr("localhost:9876");
        //3.设置接收消息对应的topic,对应的sub标签为任意
        consumer.subscribe("topic1","*");
        //3.开启监听，用于接收消息
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
                //遍历消息
                for (MessageExt msg : list) {
                    System.out.println("收到消息："+msg);
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        //4.启动接收消息的服务
        consumer.start();
        System.out.println("接受消息服务已经开启！");
        //5 不要关闭消费者！
    }
}

```



## 消息接收

```java
        //1.创建一个接收消息的对象Consumer
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("group1");
        //2.设定接收的命名服务器地址
        consumer.setNamesrvAddr("localhost:9876");
        //3.设置接收消息对应的topic,对应的sub标签为任意
        consumer.subscribe("topic1","*");
        //设置当前消费者的消费模式（默认模式：负载均衡）
        consumer.setMessageModel(MessageModel.CLUSTERING);
        //3.开启监听，用于接收消息
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
                //遍历消息
                for (MessageExt msg : list) {
                    System.out.println("收到消息："+msg);
                    System.out.println("消息是："+new String(msg.getBody()));
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        //4.启动接收消息的服务
        consumer.start();
        System.out.println("接受消息服务已经开启！");

        //5 不要关闭消费者！

```



## 多消费者模式

![image-20241013092105260](/assets/img/2024-9-7-MySQL/image-20241013092105260.png)

![image-20241013092131260](/assets/img/2024-9-7-MySQL/image-20241013092131260.png)

消息接收模式`MessageModel.CLUSTERING,MessageModel.BROADCASTING`

![image-20241013092937082](/assets/img/2024-9-7-MySQL/image-20241013092937082.png)

## 多生产者模式

## 消息类别

**同步消息**：即时性较强，需要立即有回执

![image-20241013093220033](/assets/img/2024-9-7-MySQL/image-20241013093220033.png)

**异步消息**：即时性较弱，不需要立即有回执

![image-20241013093329452](/assets/img/2024-9-7-MySQL/image-20241013093329452.png)

**单向消息**：不需要有回执，如日志

**延时消息**：消息发送时并不直接发送到消息服务器，而是根据设定的等待时间到达，起到延时到达的缓冲作用

![image-20241013093940432](/assets/img/2024-9-7-MySQL/image-20241013093940432.png)

**批量消息**：一次性发送多条消息，节约网络开销

![image-20241013094150405](/assets/img/2024-9-7-MySQL/image-20241013094150405.png)

![image-20241013094349882](/assets/img/2024-9-7-MySQL/image-20241013094349882.png)

## 消息过滤

![image-20241013094523108](/assets/img/2024-9-7-MySQL/image-20241013094523108.png)

![image-20241013094921776](/assets/img/2024-9-7-MySQL/image-20241013094921776.png)

![image-20241013094946811](/assets/img/2024-9-7-MySQL/image-20241013094946811.png)

![image-20241013095146955](/assets/img/2024-9-7-MySQL/image-20241013095146955.png)

## SpringBoot整合rocketmq

导入`rocketmq-spring-boot-starter`，配置nameserver

**生产者**：

使用`RockerMQTrmplate.convertAndSend()`

```java
//异步发送       
rocketMQTemplate.asyncSend("topic9", user, new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                
            }

            @Override
            public void onException(Throwable throwable) {
                
            }
        });

//单向发送
rocketMQTemplate.sendOneWay("topic9",user);

//延时发送
rocketMQTemplate.syncSend("topic9", MessageBuilder.withPayload("test delay").build(),2000,2);

//批量发送
List<Message> msgList = new ArrayList<>();
msgList.add(new Message("topic6", "tag1", "msg1".getBytes()));    rocketMQTemplate.syncSend("topic6",msgList,1000);

```



**消费者**：

```java
@Service
@RocketMQMessageListener(topic = "demo-topic", consumerGroup = "demo_consumer")
public class DemoConsumers1 implements RocketMQListener<user> {
    @Override
    public void onMessage(User user) {
        
    }
}

//Sql过滤
@RocketMQMessageListener(topic = "topic9",consumerGroup = "group1",selectorExpression = "age>18"
        ,selectorType= SelectorType.SQL92)

//tag过滤
@RocketMQMessageListener(topic = "topic9",consumerGroup = "group1",selectorExpression = "tag1")

//修改模式
@RocketMQMessageListener(topic = "topic9",consumerGroup = "group1",messageModel = MessageModel.BROADCASTING)
```

### 消息顺序

![image-20241013130922443](/assets/img/2024-10-12-RockerMQ/image-20241013130922443.png)

将相同的orderId放入同一个队列

```java
//生产者
for (final OrderStep order : orderList) {
            Message msg = new Message("topic1", order.toString().getBytes());
            //发送时要指定对应的消息队列选择器
            SendResult result = producer.send(msg, new MessageQueueSelector() {
                //设置当前消息发送时使用哪一个消息队列
                public MessageQueue select(List<MessageQueue> list, Message message, Object o) {
                    //根据发送的信息不同，选择不同的消息队列
                    //根据id来选择一个消息队列的对象，并返回->id得到int值
                    long orderId = order.getOrderId();
                    long mqIndex = orderId % list.size();
                    return list.get((int) mqIndex);
                }
            }, null);
            System.out.println(result);
        }

//消费者
//使用单线程的模式从消息队列中取数据，一个线程绑定一个消息队列
consumer.registerMessageListener(new MessageListenerOrderly() {
            //使用MessageListenerOrderly接口后，对消息队列的处理由一个消息队列多个线程服务，转化为一个消息队列一个线程服务
            public ConsumeOrderlyStatus consumeMessage(List<MessageExt> list, ConsumeOrderlyContext consumeOrderlyContext) {
                for (MessageExt msg : list) {
                    System.out.println(Thread.currentThread().getName()+"。消息：" + new String(msg.getBody())+"。queueId:"+msg.getQueueId());
                }
                return ConsumeOrderlyStatus.SUCCESS;
            }
        });

```

## 事务消息

![image-20241013132327107](/assets/img/2024-10-12-RockerMQ/image-20241013132327107.png)

红色部分对应正常事务过程

**事务消息状态**

1. 提交状态：允许进入队列，此消息与非事务消息无区别
2. 回滚状态：不允许进入队列，此消息等同于未发送过
3. 中间状态：完成了half消息的发送，未对MQ进行二次状态确认
4. 注意：事务消息仅与生产者有关，与消费者无关

```java
//事务消息使用的生产者是TransactionMQProducer
TransactionMQProducer producer = new TransactionMQProducer("group1");
producer.setNamesrvAddr("localhost:9876");
//添加本地事务对应的监听
producer.setTransactionListener(new TransactionListener() {
	//正常事务过程
	public LocalTransactionState executeLocalTransaction(Message message, Object o) {
		return LocalTransactionState.COMMIT_MESSAGE;
}
//事务补偿过程
	public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
		return null;
	}
});
producer.start();
Message msg = new Message("topic8",("事务消息：hello rocketmq ").getBytes("UTF-8"));
SendResult result = producer.sendMessageInTransaction(msg,null);
System.out.println("返回结果："+result);
producer.shutdown();

```

## 集群搭建

![image-20241013133906967](/assets/img/2024-10-12-RockerMQ/image-20241013133906967.png)

![image-20241013134233540](/assets/img/2024-10-12-RockerMQ/image-20241013134233540.png)

![image-20241013134428286](/assets/img/2024-10-12-RockerMQ/image-20241013134428286.png)

## 双主双从集群搭建

## 高级特性

### 消息存储特性

![image-20241013135933477](/assets/img/2024-10-12-RockerMQ/image-20241013135933477.png)

![image-20241013140140031](/assets/img/2024-10-12-RockerMQ/image-20241013140140031.png)

![image-20241013140328051](/assets/img/2024-10-12-RockerMQ/image-20241013140328051.png)

### 高效读写特性

1. 事先申请连续的硬盘内存空间，使用顺序写写入提高性能
2. 使用零拷贝技术，省略了用户态的复制![image-20241013141201001](/assets/img/2024-10-12-RockerMQ/image-20241013141201001.png)

### 消息存储结构

![image-20241013141549272](/assets/img/2024-10-12-RockerMQ/image-20241013141549272.png)

### 刷盘机制

![image-20241013141724729](/assets/img/2024-10-12-RockerMQ/image-20241013141724729.png)

![image-20241013141827852](/assets/img/2024-10-12-RockerMQ/image-20241013141827852.png)

![image-20241013141840860](/assets/img/2024-10-12-RockerMQ/image-20241013141840860.png)

### 高可用

![image-20241013141943794](/assets/img/2024-10-12-RockerMQ/image-20241013141943794.png)

![image-20241013142122099](/assets/img/2024-10-12-RockerMQ/image-20241013142122099.png)

### 负载均衡

![image-20241013142337678](/assets/img/2024-10-12-RockerMQ/image-20241013142337678.png)

![image-20241013142516721](/assets/img/2024-10-12-RockerMQ/image-20241013142516721.png)

### 消息重试

![image-20241013142720793](/assets/img/2024-10-12-RockerMQ/image-20241013142720793.png)

![image-20241013142843488](/assets/img/2024-10-12-RockerMQ/image-20241013142843488.png)

### 死信队列

当消息消费重试到达了指定次数（默认16次）后，MQ将无法被正常消费的消息称为死信消息(Dead-Letter Message)
死信消息不会被直接抛弃，而是保存到了一个全新的队列中，该队列称为死信队列(Dead-Letter Queue)

![image-20241013143010286](/assets/img/2024-10-12-RockerMQ/image-20241013143010286.png)

在监控平台中，通过查找死信，获取死信的messageld,然后通过id对死信进行精准消费

### 消息重复消费

![image-20241013143221217](/assets/img/2024-10-12-RockerMQ/image-20241013143221217.png)

![image-20241013143438574](/assets/img/2024-10-12-RockerMQ/image-20241013143438574.png)
